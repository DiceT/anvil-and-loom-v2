# Random Table Generator â€“ Design Document
Version: 0.1  
Author: T  
Target: Antigravity (implementation plan + task list)

---

## 1. Overview

This project is a **stand-alone, deterministic Random Table Generator engine** with a **React-based test UI**.  
It is designed as a **pure library first**, with a **web front end used only for testing, editing, and authoring**.

Primary goals:
- Deterministic table rolling with RNG seeds
- Flexible table schemas and result types
- Strong authoring ergonomics (smart numbering, weights, validation warnings)
- AI-assisted table review and generation
- Easy embedding into other projects via a clean API

This tool is intended for **local, personal use first**, but is architected to scale.

---

## 2. Technology Stack

- Language: TypeScript
- Runtime: Node.js
- UI (test harness): React
- State management (UI): Zustand
- Storage: Local filesystem
- Tables directory: `data/tables/`
- AI: Vendor-agnostic, OpenAI-compatible HTTP interface

---

## 3. Core Concepts

### 3.1 Tables
- Tables are JSON files stored on disk
- Tables are loaded into memory on initialization
- Tables may be incomplete and still editable
- Incomplete tables are **not rollable**

### 3.2 Determinism
- Every roll generates its own RNG seed
- Given the same seed and table state, results are identical
- External dice engines may provide a roll value directly
  - If provided, RNG is bypassed

---

## 4. Table Schema

```ts
Table {
  id: string; // UUIDv4
  schemaVersion: number;
  sourcePath: string; // filesystem path
  tableType?: string; // optional semantic grouping
  category?: string; // optional, UI-only
  name: string;
  tags: string[];
  description: string; // used by AI
  maxRoll: number; // numeric domain
  headers: string[]; // default ["ROLL", "RESULT"]
  tableData: TableRow[];
}
ts
Copy code
TableRow {
  floor: number;
  ceiling: number;
  weight?: number; // QoL only, editor-facing
  resultType: "text" | "table" | "object";
  result: string | TableReference | ObjectResult;
}
Notes:

weight never overrides floor/ceiling

weight exists solely to speed authoring and auto-row creation

floor/ceiling are authoritative

5. Result Types
5.1 Text
Plain text

May contain token references

5.2 Table Reference
ts
Copy code
TableReference {
  tag: string; // selects a random table with this tag
}
Table names are irrelevant

Tags are the only resolution mechanism

5.3 Object Result
Arbitrary JSON

Must conform to a user-defined schema

Schemas are editable via a dedicated Object Editor

Token resolution applies recursively to all string fields

6. Token Resolution
Syntax
lua
Copy code
[
  [ TAG_NAME
  ]
]
Behavior
Resolver scans all string values

Each token:

Selects a random table with the matching tag

Rolls that table

Tokens may appear in text or object results

Limits
Maximum resolution depth: 10

Cycle detection enabled

On overflow or cycle:

Token replaced with [UNRESOLVED:TAG
]

Error emitted via onError

7. Rolling Rules
7.1 Standard Rolling
Roll value compared against floor/ceiling

Gaps are allowed

First matching row normally selected

7.2 Duplicate Matches
If multiple rows match a roll:

One is selected randomly

Warning logged to console

Resolution chain records: duplicate results

7.3 d66 / d88 Modes
Treated as numeric domains

UI toggle: Normal | d66 | d88

Smart numbering and validation respect the domain

Roll resolution uses numeric comparison only

8. Validation & Warnings
Validation runs on save

Saving is never blocked

Issues generate warnings:

Gaps

Overlaps

Incomplete coverage

Missing tags

Invalid references

Non-rollable tables:

Appear in UI

Name text is dimmed

Roll actions disabled

9. Editor Behavior
Table Editor
Spreadsheet-style grid

Tab on last row creates a new row

New row auto-fills next weight

Manual add button inserts row after last

Trash icon deletes row

No bulk or multi-select

Smart Numbering
Performed on save attempt

Uses weights as guidance

Never auto-applies silently

User is notified of suggested corrections

10. Object Schema Editor
Users may define JSON schemas

Schemas are reusable

Object results must conform to schema

Validation warnings emitted for violations

11. AI Integration
Configuration
User-provided:

API base URL

Model name

API key

Capabilities
Review:

Tone

Style consistency

Duplicate detection

Generate:

Full table if empty

Fill remaining rows if partial

Optional rewrite mode

Writing Style
Preset DM styles

Optional freeform override text

Settings applied globally

12. UI Layout (Test Front End)
Left column: Folder tree (filesystem-based)

Center: Table Viewer / Editor / Creator

Right column: Persistent Result Log

Result Log
Each entry includes:

Header: Table name + Copy icon (copies entire entry)

Body:

Roll chain

Rolled values

Warnings (inline)

Result line:

Final resolved output

Copy icon (copies result only)

13. API Surface
ts
Copy code
initializeTables(): void
loadTables(): void

roll(
  tableIdOrTag: string,
  options?: {
    seed?: string;
    rollValue?: number;
}
): RollResult

onRoll(callback)
onResolveToken(callback)
onError(callback)
RollResult
ts
Copy code
RollResult {
  seed: string;
  tableChain: string[];
  rolls: number[];
  warnings: string[];
  result: string | object;
}
14. Versioning & Manifest
data/tables/_manifest.json

Tracks:

Default tables

Versions

Additions / removals

Supports future migration tooling

15. Non-Goals (for v1)
Network sync

Multi-user collaboration

Cloud storage

Bulk editing

Permission systems

16. Design Principles
Determinism over cleverness

Warnings over hard errors

Author control over automation

Library-first, UI-second

Never silently mutate user data